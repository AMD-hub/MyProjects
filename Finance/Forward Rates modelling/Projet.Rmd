
```{r}
library(tidyverse)
library(lubridate)
library(ggthemes)
library(YieldCurve)
```


# Data preparing :

## Data we're using is US rates 2009~2011 after lissage using NS : 
```{r}
data <- read_csv("C:/Users/DELL/Desktop/New Projet hhh/rates.csv", 
    col_types = cols(...1 = col_skip()))

maturities = (data %>% select(x) %>% distinct())$x
x0 = 0.1
dt = 1/12
rshort = (data %>% filter(x==x0) )$Y
```


## Adding P(t,T) : 

```{r}
rates = data %>% 
  mutate( P  = exp(-x*Y) )
```



## Ading rt : 

```{r}
rates = rates %>% 
  mutate( r = rep(rshort, each = length(maturities)) )
```

## Ading f(t,T) : 

```{r}
rates = rates %>% 
  mutate( f = ifelse(x==x0,r,-(log(P) - lag(log(P)))/(x-lag(x)) ) ) 
```


# EDA and rsik premuim : 

## Visualising $Y(t,T)$  : 

```{r}
ggplot(rates) +
  aes(x = t, y = Y, colour = x, group = x) +
  geom_line() +
  scale_color_gradient() +
  theme_bw()
```

```{r}
ggplot(rates) +
  aes(x = x, y = Y, colour = t, group = t) +
  geom_line() +
  scale_color_gradient() +
  theme_bw()
```

## Visualising Forward rates $f(t,T)$ : 

```{r}
ggplot(rates) +
  aes(x = t, y = f, colour = x, group = x) +
  geom_line() +
  scale_color_gradient() +
  theme_bw()
```

```{r}
ggplot(rates) +
  aes(x = x, y = f, colour = t, group = t) +
  geom_line() +
  scale_color_gradient() +
  theme_bw()
```

## Visualising Short rate $r_t$ :

```{r}
ggplot(rates) +
  aes(x = t, y = r) +
  geom_line(colour = "#112446") +
  theme_bw()
```
## Visualising ZCB prices $\ln P(t,T)$: 

```{r}
ggplot(rates) +
  aes(x = t, y = P, colour = x, group = x) +
  geom_line() +
  scale_color_gradient() +
  theme_bw()
```

## Risk Premuim :  

```{r}
BSparams = rates %>% select(t,x,P) %>% group_by(x) %>% 
  summarise( volatility = sqrt( (1/dt)* var( log(P/lag(P)) ,na.rm = TRUE)), return = mean(log(P/lag(P)),na.rm = TRUE)/dt + volatility^2/2 )
```

```{r}
sigma = sqrt(mean(BSparams$volatility^2))
mu = mean(BSparams$return)

qt = (mu - rates$r )/sigma
  
rates = rates %>% 
  mutate(q = qt)
```

```{r}
ggplot(rates) +
  aes(x = t, y = q) +
  geom_line(colour = "#112446") +
  theme_bw()
```


## Data we're gonna use : 
```{r}
rates
```

## saving data in csv file
```{r}
# Specify the file path where you want to save the CSV file
file_path <- "C:/Users/DELL/Desktop/New Projet hhh/ratesC.csv"

# Export data to CSV
write.csv(rates, file = file_path, row.names = TRUE)

# Print a message indicating successful export
cat("Data exported to", file_path, "\n")
```
# Benchmark Models 

## Nilson Siegle 

Calibration : 
```{r}
NSParameters = Nelson.Siegel( rates$Y, rates$x)

NSrates <- function(coef, t){
  beta0 = coef[,1]
  beta1 = coef[,2]
  beta2 = coef[,3]
  tau = coef[,4]
  return(beta0 + beta1 * (1 - exp(-t/tau))/(t/tau) + beta2 * ((1 - exp(-t/tau))/(t/tau) - exp(-t/tau))) 
}
```

Calcul des estimations : 
```{r}
curveNS  = tibble( maturity = maturities, rates = NSrates(NSParameters,maturities))
```

Visualisation de courbe : 
```{r}
ggplot(curveNS) +
  aes(x = maturity, y = rates) +
  geom_line(colour = "#112446") +
  theme_bw()
```


## Svensson  

Calibration : 
```{r}
SParameters = Svensson( rates$Y, rates$x)

Srates <- function(coef, t){
  beta0 = coef[,1]
  beta1 = coef[,2]
  beta2 = coef[,3]
  beta3 = coef[,4]
  tau1 = coef[,5]
  tau2 = coef[,6]
  term1 <- beta0
  term2 <- beta1 * (1 - exp(-t/tau1)) / (t/tau1)
  term3 <- beta2 * ((1 - exp(-t/tau1))/(t/tau1) - exp(-t/tau1))
  term4 <- beta3 * ((1 - exp(-t/tau2))/(t/tau2) - exp(-t/tau2))
  
  return(term1 + term2 + term3 + term4)
}
```

Calcul des estimations : 
```{r}
curveS  = tibble( maturity = maturities, rates = Srates(SParameters,maturities))
```

Visualisation de courbe : 
```{r}
ggplot(curveS) +
  aes(x = maturity, y = rates) +
  geom_line(colour = "#112446") +
  theme_bw()
```

## Comparaison des models benchmark : 

```{r}
ggplot(rates) +
  aes(x = x, y = Y, colour = t, group = t) +
  geom_line() +
  geom_line(  aes(x = x, y =  NSrates(NSParameters,x) ),size = 1.2, colour = "orange" )+
  geom_point(  aes(x = x, y =  NSrates(NSParameters,x) ),size = 1.6, colour = "orange" )+
  geom_line(  aes(x = x, y =  Srates(SParameters,x) ),size = 1.2, colour = "green" )+
  geom_point(  aes(x = x, y =  Srates(SParameters,x) ),size = 1.6, colour = "green" )+
  theme_bw()
```

# Proposed Model (EL QALLI RATES) :

```{r}
# Defining initial Values :
delta = 0.1
N = length(maturities)
time = rates$t
f0 = (rates %>% filter(t==0) )$f

## Initial params :
params = c(
lambda0 = 0.04157374,
lambda1 = 0.01830442,
lambda2 = 0.0926567,
kappa0  = 0.09287434,
kappa1  = 0.01661409,
kappa2  = 0.0436558
          )
```

```{r}
# Boundry conditions :
Lboundry = rates %>% filter(x==x0) %>% select(f)
Uboundry = rates %>% filter(x==10) %>% select(f)


# Function for predictions : 
Fonc <- function(t,r,q,params){
  N = length(r)
  lambda0 = params[1]
  lambda1 = params[2]
  lambda2 = params[3]
  kappa0  = params[4]
  kappa1  = params[5]
  kappa2  = params[6]
  
  sigma0  <- function(t, s, x) {
    return(lambda0 * exp(-kappa0 * (t  +x- s)))
  }
  mu0     <- function(t, s, x) {
    term1 <- exp(-kappa0 * (t  +x-s))
    term2 <- exp(kappa0 * s) - exp(-kappa0 * (t  +x- 2 * s))
    return(lambda0^2 * term1 * (term2 / kappa0))
  }
  sigma1  <- function(t, s, x) {
    return(lambda1 * exp(-kappa1 * (t + x-s)))
  }
  mu1     <- function(t, s, x) {
    term1 <- exp(-kappa1 * (t  +x- s))
    term2 <- exp(kappa1 * s) - exp(-kappa1 * (t +x- 2 * s))
    return(lambda1^2 * term1 * (term2 / kappa1))
  }
  sigma2  <- function(t, s, x) {
    return(lambda2 * exp(-kappa2 * (t +x- s)))
  }
  mu2     <- function(t, s, x) {
    term1 <- exp(-kappa2 * (t  +x- s))
    term2 <- exp(kappa2 * s) - exp(-kappa2 * (t  +x- 2 * s))
    return(lambda2^2 * term1 * (term2 / kappa2))
  }
  f         <- function(t, l, c, r, dW) {
    term1 <- c + ((r - l) / (2 * delta) + mu0(t,t,c) * c^2 + mu1(t,t,c) * ((r - l) / (2 * delta))^2 + mu2(t,t,c) * ((r - 2 * c + l) / delta^2)^2) * dt
    term2 <- sigma0(t,t,c) * c * dW[1] + sigma1(t,t,c) * ((r - l) / (2 * delta)) * dW[2] + sigma2(t,t,c) * ((r - 2 * c + l) / delta^2) * dW[3]
    result <- term1 + term2
    return(result)
  }
  

  rnext = r 
  for( k in 2:(N-1) ){
    dW = c(0,0,0) + rep(q*dt,3)/3
    rnext[k] = f(t, r[k-1], r[k], r[k+1], dW)
  }
  dW = c(0,0,0) + rep(q*dt,3)/3
  rnext[1] = f(t, r[1] , r[1], r[1+1], dW)
  rnext[N] = f(t, r[N-1] , r[N], r[N] , dW)
  
  return(rnext)
}

```

```{r}
# Defining the norm of vector : 
norm2 <- function(x){
  sum(x^2)
}

# Define the mean squared error function
mse <- function(params) {
  mse_value = 0
  tt = 0
  while(tt<3){
    r =  as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(f))$f
    q =  as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(q))$q[1]
    prediction <- Fonc(tt,r,q,params)
    tt = tt+dt
    r =  as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(f))$f
    mse_value <- mse_value + norm2(r-prediction)*100000
  }
  return(mse_value/length(time))
}
```


```{r}
# Define the optimization algorithm
resultat <- optim(par = params , fn = mse)

params = resultat$par

paste0("mse = ", round(sqrt(resultat$value)/10,2),"%")
```

## Backtesting for $h = 1$ 

```{r}
tt = 6*dt
r = as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(f))$f
N = length(r)
q =  as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(q))$q[1]

freal =  as.vector(rates %>% filter(abs(t-tt-dt)<dt/2) %>% select(f))$f
Yreal =  as.vector(rates %>% filter(abs(t-tt-dt)<dt/2) %>% select(Y))$Y

freallag =  as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(f))$f
Yreallag =  as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(Y))$Y

festim =  Fonc(tt+dt,r = r,q=q, params = params)
Yestim = delta*cumsum(festim)/maturities
```

```{r}
CurveQ = tibble(
  x = maturities ,
  freal = freal, 
  Yreal = Yreal,
  Yreallag =Yreallag,
  freallag = freallag,
  
  festim = festim,
  Yestim = Yestim,
  
  YestimNS = curveNS$rates,
  YestimS = curveS$rates
  )
```


```{r}
CurveQ %>% 
  pivot_longer(cols = c(Yreal,Yestim,Yreallag,YestimNS,YestimS),names_to = "Method", values_to = "Y(t,T)") %>% 
  ggplot() +
    aes(x = x, y = `Y(t,T)`, colour = Method, group = Method) +
    geom_line() +
    scale_color_hue(direction = 1) +
    theme_bw()
```
```{r}
## Erreurs d'estimations : 
cat(
  "\n",
  "Erreur NS  =", 1000*norm2(Yreal - CurveQ$YestimNS), "%\n",
  "Erreur Sv  =", 1000*norm2(Yreal - CurveQ$YestimS) , "%\n",
  "Erreur lag =", 1000*norm2(Yreal- CurveQ$Yreallag) , "%\n",
  "Erreur TF  =", 1000*norm2(Yreal - CurveQ$Yestim)  , "%\n"
)
```


## Backtesting for $h>1$ : 

```{r}
tt = 18*dt
h = 12
N = length(r)
r = as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(f))$f

freal =  as.vector(rates %>% filter(abs(t-tt-h*dt)<dt/2) %>% select(f))$f
Yreal =  as.vector(rates %>% filter(abs(t-tt-h*dt)<dt/2) %>% select(Y))$Y

freallag =  as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(f))$f
Yreallag =  as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(Y))$Y

for(i in 1:h){ 
  q =  as.vector(rates %>% filter(abs(t-tt)<dt/2) %>% select(q))$q[1]
  festim =  Fonc(tt,r = r,q=q, params = params)
  tt = tt+dt
  r = festim
  }
Yestim = delta*cumsum(festim)/maturities
```

```{r}
CurveQ = tibble(
  x = maturities ,
  freal = freal, 
  Yreal = Yreal,
  Yreallag =Yreallag,
  freallag = freallag,
  
  festim = festim,
  Yestim = Yestim,
  
  YestimNS = curveNS$rates,
  YestimS = curveS$rates
  )
```


```{r}
CurveQ %>% 
  pivot_longer(cols = c(Yreal,Yestim,Yreallag,YestimNS,YestimS),names_to = "Method", values_to = "Y(t,T)") %>% 
  ggplot() +
    aes(x = x, y = `Y(t,T)`, colour = Method, group = Method) +
    geom_line() +
    scale_color_hue(direction = 1) +
    theme_bw()
```


```{r}
## Erreurs d'estimations : 
cat(
  "\n",
  "Erreur NS  =", 1000*norm2(Yreal - CurveQ$YestimNS), "%\n",
  "Erreur Sv  =", 1000*norm2(Yreal - CurveQ$YestimS) , "%\n",
  "Erreur lag =", 1000*norm2(Yreal- CurveQ$Yreallag) , "%\n",
  "Erreur TF  =", 1000*norm2(Yreal - CurveQ$Yestim)  , "%\n"
)
``` 







